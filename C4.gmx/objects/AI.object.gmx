<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Init AI
var column = 0;
var found  = false;
var ds_Bad = ds_list_create(); // Array of Bad columns to play in
var ds_No  = ds_list_create(); // Array of impossible columns to play in
randomize();

for(var i=0; i &lt; global.gWidth; i++)
{
    if start_drop(i)
    {
        // Check for AI win
        global.grid[# global.grid_x, global.grid_y] = global.AI_Color;
        if win_check(global.AI_Color)
        {
            // Found a winning space
            found = true;
            column = i;
            break;
        } 
        else
        {
            // Check for player 1 win
            global.grid[# global.grid_x, global.grid_y] = global.P1_Color;    
            if win_check(global.P1_Color)
            {
                // Found a winning space
                // Take it to prevent P1 from winning
                global.grid[# global.grid_x, global.grid_y] = global.AI_Color; 
                found = true;
                column = i;
                break;
            }
        
            // Not a winning space, set it back to empty
            global.grid[# global.grid_x, global.grid_y] = EMPTY;   
        } 
    }  
}

if found
{
    // Place winning disc
    instance_create(get_btn_x(column), get_btn_y(column), Disc);
}
else
{
    // Don't play somewhere that will cause P1 to win
    // Find Danger columns (all the columns we can't play in)
    for(var i=0; i &lt; global.gWidth; i++)
    {
        if start_drop(i)
        {
            // Set AI place in grid
            var hist_x = global.grid_x;
            var hist_y = global.grid_y;
            global.grid[# global.grid_x, global.grid_y] = global.AI_Color;
            
            // Loop through each possible P1 move
            for(var j=0; j &lt; global.gWidth; j++)
            {
                if start_drop(j)
                {
                    // Set P1 place in grid
                    global.grid[# global.grid_x, global.grid_y] = global.P1_Color;
                    
                    if win_check(global.P1_Color)
                    {
                        // Found a winning space for P1
                        // Add it to Bad columns array
                        if !ds_list_contains(ds_Bad, i)
                        {
                            ds_list_add(ds_Bad, i); 
                        }
                    }
                    
                    // Set P1 place in grid back to empty
                    global.grid[# global.grid_x, global.grid_y] = EMPTY;
                }
                else
                {
                    // This doesnt make sense
                    // If they player cant play here
                    // Because the row is full
                    // Doesn't mean we can't play here
                    if !ds_list_contains(ds_Bad, i)
                    {
                        ds_list_add(ds_Bad, i); 
                    }   
                }
            }
            
            // Set P1 place in grid back to empty
            global.grid[# hist_x, hist_y] = EMPTY;
        }
    }
    
    if (ds_list_size(ds_Bad) &lt;= 0)
    {
        // If no Danger columns, advance our own lines
        
        // ***TEMPORARY*** play randomly
        column = irandom(6);
        
        while !start_drop(column)
        {
            column = irandom(6);    
        }
        
        global.grid[# global.grid_x, global.grid_y] = global.AI_Color;
        
        // Place random disc
        instance_create(get_btn_x(column), get_btn_y(column), Disc);
    }
    else if (ds_list_size(ds_Bad) != global.gWidth)
    {     
        // play randomly, but not in a danger column
        column = irandom(6);
    
        while !start_drop(column) or ds_list_contains(ds_Bad, column)
        {   
            column = irandom(6);    
        }
    
        global.grid[# global.grid_x, global.grid_y] = global.AI_Color;
        
        // Place random disc
        instance_create(get_btn_x(column), get_btn_y(column), Disc);
    }
    else
    {
        // play randomly in a danger column
        column = irandom(6);
    
        while !start_drop(column)
        {   
            column = irandom(6);    
        }
    
        global.grid[# global.grid_x, global.grid_y] = global.AI_Color;
        
        // Place random disc
        instance_create(get_btn_x(column), get_btn_y(column), Disc);
    }
}

instance_destroy();


// finally play randomly
/*column = irandom(6);

while !start_drop(column)
{
    column = irandom(6);    
}

global.grid[# global.grid_x, global.grid_y] = global.AI_Color;

// Place random disc
instance_create(get_btn_x(column), get_btn_y(column), Disc);*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
